<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lesson 8</title>
</head>

<body>
  <script>
    // 1. Не выполняя кода, ответить, что выведет браузер и почему:
    // if (!("a" in window)) {
    //   var a = 1;
    // }
    // alert(a);
    // Если у обьекта window нет переменной "a" задать переменную а = 1. Так как переменная есть(почему то), в if будет false, переменная не создается и alert выведет undefined.



    // var b = function a(x) {
    //   x && a(--x);
    // };
    // alert(a);
    // Функция а хранится в переменной b и хоть она имеет свое имя вызываться должна через b();



    // function a(x) {
    //   return x * 2;
    // }
    // var a;
    // alert(a);
    // Тут полагаю так как var просто инициализировал переменную, без задания значения, alert находит ту переменную а у которой есть значение.



    // function b(x, y, a) {
    //   arguments[2] = 10;
    //   alert(a);
    // }
    // b(1, 2, 3);
    // Объект arguments — это подобный массиву объект, который содержит аргументы, переданные в функцию. В функцию передается 1,2,3 потом 3 перезаписывается на 10 и выводится.



    // function a() {
    //   alert(this);
    // }
    // a.call(null);
    //Метод call() вызывает функцию с указанным значением this и индивидуально предоставленными аргументами. 
    // fun.call(thisArg[, arg1[, arg2[, ...]]])
    // где thisArg : Значение this, предоставляемое для вызова функции fun. Обратите внимание, что this может не быть реальным значением, видимым этим методом: если метод является функцией в нестрогом режиме (en-US), значения null и undefined будут заменены глобальным объектом, а примитивные значения будут упакованы в объекты.
    // Поэтому alert выведет обьект window.
  </script>
</body>

</html>